package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"fmt"
	"siddhant94/iptables-sync/sync"
	"strings"
)
var (
	v4Enabled bool = true
	v6Enabled bool = false
)

func main() {
	fmt.Println("Iptables SYNC")
	syncClient, err := sync.New(v4Enabled, v6Enabled)
	if err != nil {
		fmt.Errorf("error creating IPTables instance: %v", err)
		return
	}
	//tblList := syncClient.GetTables()

	//for _, v := range tblList {
	//	fmt.Println("Running for Table:")
	//	fmt.Println(v)
	//	syncClient.SaveTable(string(v))
	//}
	//syncClient.PrintIpTableData()
	// TODO: Get applied rules, and compare against iptData
	saveData, err := syncClient.SaveEntireIPTable()
	if err != nil {
		fmt.Println("Error executing Ip Tables save")
	}
	res := parseIPTablesSave(saveData)
	fmt.Println("Final Datastructure:")
	//fmt.Println(res)
	PrettyPrint(res)
}
type Chain string
var commitBytes = "COMMIT"
var spaceBytes  = " "
func parseIPTablesSave(data []byte) map[Chain][]string {
	chainsMap := make(map[Chain][]string)
	tableToChainMap := make(map[string][]string)
	tablePrefix := "*"
	bytesReader := bytes.NewReader(data)
	bufReader := bufio.NewReader(bytesReader)
	scanner := bufio.NewScanner(bufReader)
	fmt.Println("Printing Scanner loop")
	count := 0
	for scanner.Scan() {
		if count == 4 { break }
		line := scanner.Text()
		fmt.Println(line)
		// TODO: To separate IPv4 & v6, we would parse "Generated by" comment part.
		if line[0] == '#' || strings.HasPrefix(line, commitBytes) { //comments or COMMIT's from iptables-save
			continue
		}
		// Get to table line
		var tblName string
		//var rules []string
		if tableNameIndex := strings.Index(line, tablePrefix); tableNameIndex != -1 {
			// Found table line
			tblName = line[(tableNameIndex+1):]
			fmt.Println("Table: "+tblName)
			count++
			// Reset rules []string. PS: Change into bytes buffer and call native Reset( method.
			continue
		} else if line[0] == ':' && len(line) > 1 { // i.e. is a chain line
			// We assume that the <line> contains space - chain lines have 3 fields,
			// space delimited. If there is no space, this line will panic.
			spaceIndex := strings.Index(line, spaceBytes)
			if spaceIndex == -1 {
				panic(fmt.Sprintf("Unexpected chain line in iptables-save output: %v", string(line)))
			}
			chain := line[1:spaceIndex]
			tableToChainMap[tblName] = append(tableToChainMap[tblName], chain)
			continue
			// TODO: Add logic to see if we need this chain, then only we'll parse
		} else if line[0] == '-' { // Rule line
			//TODO: Separate these into target source op etc
			// Refer: man iptables
			// COMMANDS: -A(append), -N (new chain), -X(delete)
			// -A has arguments Chain RuleSpec
			//cmd := line[0:2]
			segments := strings.SplitN(line, spaceBytes, 3) // assuming space
			//fmt.Printf("\nSegments: \nCmd: %s\nChain: %s\nRuleSpec: %v\n", segments[0], segments[1], segments[2])
			key := segments[1] + "/" + tblName
			chainsMap[Chain(key)] = append(chainsMap[Chain(key)], line)
		}
	}
	return chainsMap
}

func PrettyPrint(v interface{}) (err error) {
	b, err := json.MarshalIndent(v, "", "  ")
	if err == nil {
		fmt.Println(string(b))
	}
	return
}

//func main() {
//	fmt.Println("Iptables SYNC")
//	ipt, err := iptables.New()
//	if err != nil {
//		fmt.Printf("Failed to create new iptables datastructure: %v", err)
//		return
//	}
//	fmt.Printf("\n%+v\n", ipt)
//	// Listing existing chains per table
//	//TODO: Make an array for tables raw, mangle etc
//	originaListChain, err := ipt.ListChains("filter")
//	if err != nil {
//		fmt.Printf("ListChains of Initial failed: %v", err)
//		return
//	}
//	fmt.Println("Original ListChain")
//	fmt.Printf("\n%+v\n", originaListChain)
//
//	// List each rule
//	for _, v := range originaListChain {
//		rules, err := ipt.List("filter", v)
//		if err != nil {
//			fmt.Printf("Error in listing rules: %v", err)
//			return
//		}
//		fmt.Printf("\nRules:\n%+v", rules)
//	}
//}
